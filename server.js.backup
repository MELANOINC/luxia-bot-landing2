require('dotenv').config();
const express = require('express');
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const session = require('express-session');
const cors = require('cors');
const { pool } = require('./db/pool');
const Web3Service = require('./services/web3Service');
const app = express();
const port = Number(process.env.PORT || 5678);
const host = process.env.HOST || '127.0.0.1';

// Middleware
app.use(cors()); // <-- FALTABA ESTO! Para webhooks de N8N
app.use(express.json());
app.use(session({
  secret: process.env.SESSION_SECRET || 'tu-secreto-aqui',
  resave: false,
  saveUninitialized: true
}));
app.use(passport.initialize());
app.use(passport.session());

// Configuración Passport Google OAuth
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: `http://${host}:${port}/auth/google/callback`
  },
  (accessToken, refreshToken, profile, done) => {
    // Aquí puedes guardar el usuario en BD si quieres
    return done(null, profile);
  }
));

passport.serializeUser((user, done) => {
  done(null, user);
});

passport.deserializeUser((user, done) => {
  done(null, user);
});

app.get('/', (req, res) => res.send(`Hola desde ${port}`));

// Ruta de prueba de conexión a BD
app.get('/db-ping', async (req, res) => {
	try {
		const r = await pool.query('select 1 as ok');
		res.json({ ok: true, result: r.rows[0] });
	} catch (e) {
		res.status(500).json({ ok: false, error: e.message });
	}
});

// Endpoint de ejemplo: lista elementos desde public.items (si existe)
app.get('/items', async (req, res) => {
	try {
		// Verificar existencia de la tabla
		const check = await pool.query(
			"select to_regclass('public.items') as tbl"
		);
		if (!check.rows[0] || !check.rows[0].tbl) {
			return res.status(404).json({
				ok: false,
				error: "La tabla public.items no existe",
				howToCreate: "CREATE TABLE public.items (id uuid primary key default gen_random_uuid(), name text not null, created_at timestamptz default now());"
			});
		}
		const { rows } = await pool.query('select * from public.items order by 1 desc limit 20');
		res.json({ ok: true, count: rows.length, items: rows });
	} catch (e) {
		res.status(500).json({ ok: false, error: e.message });
	}
});

// Endpoint para insertar nuevo item
app.post('/items', async (req, res) => {
	try {
		// Verificar existencia de la tabla
		const check = await pool.query(
			"select to_regclass('public.items') as tbl"
		);
		if (!check.rows[0] || !check.rows[0].tbl) {
			return res.status(404).json({
				ok: false,
				error: "La tabla public.items no existe",
				howToCreate: "CREATE TABLE public.items (id uuid primary key default gen_random_uuid(), name text not null, created_at timestamptz default now());"
			});
		}
		// Validación básica
		const { name } = req.body;
		if (!name || typeof name !== 'string' || name.trim().length === 0) {
			return res.status(400).json({
				ok: false,
				error: "Campo 'name' requerido y no vacío"
			});
		}
		// Insertar y devolver el registro creado
		const { rows } = await pool.query(
			'insert into public.items (name) values ($1) returning *',
			[name.trim()]
		);
		res.status(201).json({ ok: true, item: rows[0] });
	} catch (e) {
		res.status(500).json({ ok: false, error: e.message });
	}
});

// Rutas de autenticación Google
app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile', 'email'] })
);

app.get('/auth/google/callback',
  passport.authenticate('google', { failureRedirect: '/' }),
  (req, res) => {
    // Autenticación exitosa
    res.redirect('/profile');
  }
);

// Ruta protegida de ejemplo
app.get('/profile', (req, res) => {
  if (!req.user) {
    return res.redirect('/auth/google');
  }
  res.json({
    ok: true,
    user: {
      id: req.user.id,
      displayName: req.user.displayName,
      email: req.user.emails ? req.user.emails[0].value : null
    }
  });
});

// Logout
app.get('/logout', (req, res) => {
  req.logout(() => {
    res.redirect('/');
  });
});

// Webhook endpoint para N8N
app.post('/webhook/n8n', async (req, res) => {
  try {
<<<<<<< HEAD
    console.log('📨 Webhook N8N recibido:', req.body);
    
    // Procesar los datos del webhook
    const data = req.body;
    
    // Aquí puedes guardar en BD o procesar los datos
    // Ejemplo: guardar en tabla de logs
    if (data && Object.keys(data).length > 0) {
      // Opcional: guardar en BD
      // await pool.query('INSERT INTO webhook_logs (data, created_at) VALUES ($1, NOW())', [JSON.stringify(data)]);
      
      res.json({ 
        ok: true, 
        message: 'Webhook procesado correctamente',
        received: data 
      });
    } else {
      res.json({ ok: true, message: 'Webhook vacío recibido' });
    }
  } catch (error) {
    console.error('❌ Error en webhook N8N:', error);
    res.status(500).json({ ok: false, error: error.message });
  }
});

// Endpoint GET para testear webhook
app.get('/webhook/n8n', (req, res) => {
  res.json({ 
    ok: true, 
    message: 'Webhook N8N endpoint activo',
    method: 'GET (para testing)',
    postEndpoint: '/webhook/n8n'
  });
});

=======
    // Verificar token de N8N
    const authHeader = req.headers.authorization;
    const expectedToken = process.env.N8N_WEBHOOK_TOKEN || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5M2YzOWUwYy01MTQ2LTRhNTEtYmMzMy1hYWM0MmNhODJkZDMiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzU3OTI1MzI1LCJleHAiOjE3NjA1MDA4MDB9.dfNaflEIfMgDKQrgHP8tVcC0YhXXUfXawRx3sZLJF_Q';
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token de autorización requerido' });
    }
    
    const token = authHeader.substring(7); // Remover 'Bearer '
    
    if (token !== expectedToken) {
      return res.status(401).json({ error: 'Token inválido' });
    }
    
    // Procesar datos del webhook
    const webhookData = req.body;
    console.log('Webhook N8N recibido:', webhookData);
    
    // Aquí puedes procesar los datos según tus necesidades
    // Por ejemplo, guardar en BD, enviar email, etc.
    
    // Respuesta de éxito
    res.json({ 
      ok: true, 
      message: 'Webhook procesado correctamente',
      received: webhookData 
    });
    
  } catch (error) {
    console.error('Error en webhook N8N:', error);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// Initialize Web3 Service
const web3Service = new Web3Service();

// Web3 and Smart Contract endpoints
app.get('/web3/status', async (req, res) => {
  try {
    const isInitialized = web3Service.provider !== null;
    if (!isInitialized) {
      return res.json({ 
        ok: false, 
        message: 'Web3 service not initialized',
        provider: null,
        contracts: null
      });
    }

    const blockNumber = await web3Service.getBlockNumber();
    const signerAddress = web3Service.signer ? web3Service.signer.address : null;
    
    res.json({
      ok: true,
      message: 'Web3 service active',
      blockNumber,
      signer: signerAddress,
      contracts: {
        luxia: web3Service.contractAddresses.luxia,
        notorious: web3Service.contractAddresses.notorious
      }
    });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

// LUXIA Token endpoints
app.get('/tokens/luxia/info', async (req, res) => {
  try {
    const info = await web3Service.getLuxiaTokenInfo();
    res.json({ ok: true, token: info });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.get('/tokens/luxia/balance/:address', async (req, res) => {
  try {
    const { address } = req.params;
    const balance = await web3Service.getLuxiaBalance(address);
    res.json({ ok: true, address, balance });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/tokens/luxia/transfer', async (req, res) => {
  try {
    const { to, amount } = req.body;
    if (!to || !amount) {
      return res.status(400).json({ ok: false, error: 'Missing required fields: to, amount' });
    }
    
    const result = await web3Service.transferLuxia(to, amount);
    res.json({ ok: true, transaction: result });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/tokens/luxia/mint', async (req, res) => {
  try {
    const { to, amount } = req.body;
    if (!to || !amount) {
      return res.status(400).json({ ok: false, error: 'Missing required fields: to, amount' });
    }
    
    const result = await web3Service.mintLuxia(to, amount);
    res.json({ ok: true, transaction: result });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

// NOTORIOUS Token endpoints
app.get('/tokens/notorious/info', async (req, res) => {
  try {
    const info = await web3Service.getNotoriusTokenInfo();
    res.json({ ok: true, token: info });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.get('/tokens/notorious/balance/:address', async (req, res) => {
  try {
    const { address } = req.params;
    const balance = await web3Service.getNotoriusBalance(address);
    res.json({ ok: true, address, balance });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/tokens/notorious/transfer', async (req, res) => {
  try {
    const { to, amount } = req.body;
    if (!to || !amount) {
      return res.status(400).json({ ok: false, error: 'Missing required fields: to, amount' });
    }
    
    const result = await web3Service.transferNotorious(to, amount);
    res.json({ ok: true, transaction: result });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/tokens/notorious/set-fee', async (req, res) => {
  try {
    const { feePercent } = req.body;
    if (feePercent === undefined) {
      return res.status(400).json({ ok: false, error: 'Missing required field: feePercent' });
    }
    
    const result = await web3Service.setNotoriusFee(feePercent);
    res.json({ ok: true, transaction: result });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/tokens/notorious/blacklist', async (req, res) => {
  try {
    const { address } = req.body;
    if (!address) {
      return res.status(400).json({ ok: false, error: 'Missing required field: address' });
    }
    
    const result = await web3Service.blacklistAddress(address);
    res.json({ ok: true, transaction: result });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/tokens/notorious/pause', async (req, res) => {
  try {
    const result = await web3Service.pauseNotorious();
    res.json({ ok: true, transaction: result });
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

// Smart contract management endpoints
app.post('/web3/initialize', async (req, res) => {
  try {
    const { providerUrl } = req.body;
    const url = providerUrl || 'http://localhost:8545';
    
    const success = await web3Service.initialize(url);
    if (success) {
      res.json({ ok: true, message: 'Web3 service initialized', provider: url });
    } else {
      res.status(500).json({ ok: false, error: 'Failed to initialize Web3 service' });
    }
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.post('/web3/load-contracts', async (req, res) => {
  try {
    const { luxiaAddress, notoriusAddress } = req.body;
    if (!luxiaAddress || !notoriusAddress) {
      return res.status(400).json({ 
        ok: false, 
        error: 'Missing required fields: luxiaAddress, notoriusAddress' 
      });
    }
    
    const success = await web3Service.loadContracts(luxiaAddress, notoriusAddress);
    if (success) {
      res.json({ 
        ok: true, 
        message: 'Contracts loaded successfully',
        contracts: {
          luxia: luxiaAddress,
          notorious: notoriusAddress
        }
      });
    } else {
      res.status(500).json({ ok: false, error: 'Failed to load contracts' });
    }
  } catch (error) {
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.listen(port, host, () => console.log(`Servidor en http://${host}:${port}`));
