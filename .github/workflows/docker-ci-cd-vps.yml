name: 🚀 CI/CD Docker + Deploy VPS (Producción)

# Configuración de triggers para ejecución automática y manual
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Entorno de deployment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

# Variables de entorno globales para estandarización
env:
  DOCKER_IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/luxia-bot-landing2
  DOCKER_TAG: latest
  CONTAINER_NAME: luxia-bot-landing2
  APP_PORT: 3000
  HOST_PORT: 80

jobs:
  # Job 1: Build y Push de imagen Docker
  build-and-push:
    name: 🏗️ Build & Push Docker Image
    runs-on: ubuntu-latest
    
    outputs:
      image: ${{ steps.meta.outputs.tags }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: 📥 Checkout del código fuente
        uses: actions/checkout@v4
        
      - name: 🛠️ Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: 🔐 Login a DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          
      - name: 📋 Extraer metadata de imagen
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: 🚀 Build y Push imagen Docker
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          
      - name: ✅ Verificar imagen creada
        run: |
          echo "✅ Imagen Docker creada exitosamente:"
          echo "📦 Nombre: ${{ env.DOCKER_IMAGE_NAME }}"
          echo "🏷️ Tags: ${{ steps.meta.outputs.tags }}"
          echo "🔍 Digest: ${{ steps.build.outputs.digest }}"

  # Job 2: Deploy a VPS
  deploy-to-vps:
    name: 🌐 Deploy a VPS
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    environment: 
      name: ${{ github.event.inputs.deploy_environment || 'production' }}
      url: http://${{ secrets.SERVER_HOST }}
    
    steps:
      - name: 📥 Checkout para scripts de deploy
        uses: actions/checkout@v4
        
      - name: 🚀 Deploy vía SSH a VPS
        uses: appleboy/ssh-action@v1.0.3
        env:
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          APP_PORT: ${{ env.APP_PORT }}
          HOST_PORT: ${{ env.HOST_PORT }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          envs: DOCKER_IMAGE,CONTAINER_NAME,APP_PORT,HOST_PORT
          script: |
            echo "🚀 Iniciando deployment en VPS..."
            
            # Función para logging con timestamp
            log() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
            }
            
            # Verificar Docker instalado
            if ! command -v docker &> /dev/null; then
              log "❌ ERROR: Docker no está instalado"
              exit 1
            fi
            
            log "📦 Descargando imagen Docker: $DOCKER_IMAGE"
            if ! docker pull $DOCKER_IMAGE; then
              log "❌ ERROR: No se pudo descargar la imagen"
              exit 1
            fi
            
            # Backup del contenedor actual (si existe)
            if docker ps -q -f name=$CONTAINER_NAME > /dev/null; then
              log "💾 Creando backup del contenedor actual..."
              docker tag $DOCKER_IMAGE ${DOCKER_IMAGE}-backup-$(date +%Y%m%d-%H%M%S) || true
            fi
            
            log "🛑 Deteniendo contenedor existente..."
            docker stop $CONTAINER_NAME || true
            
            log "🗑️ Removiendo contenedor existente..."
            docker rm $CONTAINER_NAME || true
            
            log "🚀 Iniciando nuevo contenedor..."
            docker run -d \
              --name $CONTAINER_NAME \
              --restart unless-stopped \
              -p $HOST_PORT:$APP_PORT \
              --health-cmd="curl -f http://localhost:$APP_PORT/health || exit 1" \
              --health-interval=30s \
              --health-timeout=10s \
              --health-retries=3 \
              -e NODE_ENV=production \
              $DOCKER_IMAGE
            
            if [ $? -eq 0 ]; then
              log "✅ Contenedor iniciado exitosamente"
            else
              log "❌ ERROR: Falló el inicio del contenedor"
              
              # Intentar rollback
              log "🔄 Intentando rollback..."
              BACKUP_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "${DOCKER_IMAGE}-backup" | head -1)
              if [ ! -z "$BACKUP_IMAGE" ]; then
                docker run -d --name $CONTAINER_NAME --restart unless-stopped -p $HOST_PORT:$APP_PORT $BACKUP_IMAGE
                log "🔄 Rollback completado con imagen: $BACKUP_IMAGE"
              else
                log "❌ No hay imagen de backup disponible"
              fi
              exit 1
            fi
            
            # Esperar a que el servicio esté listo
            log "⏳ Esperando que el servicio esté listo..."
            sleep 15
            
            # Verificar health check
            for i in {1..10}; do
              if docker exec $CONTAINER_NAME curl -f http://localhost:$APP_PORT/health > /dev/null 2>&1; then
                log "✅ Servicio respondiendo correctamente"
                break
              else
                if [ $i -eq 10 ]; then
                  log "❌ ERROR: Servicio no responde después de 10 intentos"
                  docker logs $CONTAINER_NAME --tail 50
                  exit 1
                fi
                log "⏳ Intento $i/10 - Esperando respuesta del servicio..."
                sleep 10
              fi
            done
            
            # Limpiar imágenes antiguas (mantener las últimas 3)
            log "🧹 Limpiando imágenes antiguas..."
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
              grep "${{ env.DOCKER_IMAGE_NAME }}" | \
              tail -n +4 | \
              awk '{print $1}' | \
              xargs -r docker rmi || true
            
            log "🎉 ¡Deployment completado exitosamente!"
            log "🌐 Aplicación disponible en: http://$(hostname -I | awk '{print $1}'):$HOST_PORT"
            
      - name: 🔍 Verificar deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            echo "🔍 Verificando estado del deployment..."
            echo "📊 Estado del contenedor:"
            docker ps -f name=${{ env.CONTAINER_NAME }} --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "📈 Logs recientes del contenedor:"
            docker logs ${{ env.CONTAINER_NAME }} --tail 10
            
            echo "💾 Uso de recursos:"
            docker stats ${{ env.CONTAINER_NAME }} --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            
      - name: 📧 Notificar resultado del deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ DEPLOYMENT EXITOSO"
            echo "🌐 Aplicación desplegada en: http://${{ secrets.SERVER_HOST }}"
            echo "🚀 Imagen: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
            echo "📅 Fecha: $(date)"
          else
            echo "❌ DEPLOYMENT FALLÓ"
            echo "🔍 Revisa los logs para más detalles"
          fi

  # Job 3: Pruebas post-deployment (opcional)
  post-deployment-tests:
    name: 🧪 Pruebas Post-Deployment
    needs: deploy-to-vps
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && success()
    
    steps:
      - name: 🌐 Verificar endpoint de salud
        run: |
          echo "🔍 Verificando endpoint de salud..."
          MAX_ATTEMPTS=10
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if curl -f -s http://${{ secrets.SERVER_HOST }}/health > /dev/null; then
              echo "✅ Endpoint de salud respondiendo correctamente"
              exit 0
            else
              echo "⏳ Intento $ATTEMPT/$MAX_ATTEMPTS fallido, reintentando en 15 segundos..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          echo "❌ ERROR: Endpoint de salud no responde después de $MAX_ATTEMPTS intentos"
          exit 1
          
      - name: 📊 Generar reporte de deployment
        if: always()
        run: |
          echo "## 📊 Reporte de Deployment" >> $GITHUB_STEP_SUMMARY
          echo "| Métrica | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| 🌐 Servidor | ${{ secrets.SERVER_HOST }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 🚀 Imagen | ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 📅 Fecha | $(date) |" >> $GITHUB_STEP_SUMMARY
          echo "| ✅ Estado | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 🔗 URL | http://${{ secrets.SERVER_HOST }} |" >> $GITHUB_STEP_SUMMARY