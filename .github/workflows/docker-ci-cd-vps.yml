name: ðŸš€ CI/CD Docker + Deploy VPS (ProducciÃ³n)

# ConfiguraciÃ³n de triggers para ejecuciÃ³n automÃ¡tica y manual
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Entorno de deployment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

# Variables de entorno globales para estandarizaciÃ³n
env:
  DOCKER_IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/luxia-bot-landing2
  DOCKER_TAG: latest
  CONTAINER_NAME: luxia-bot-landing2
  APP_PORT: 3000
  HOST_PORT: 80

jobs:
  # Job 1: Build y Push de imagen Docker
  build-and-push:
    name: ðŸ—ï¸ Build & Push Docker Image
    runs-on: ubuntu-latest
    
    outputs:
      image: ${{ steps.meta.outputs.tags }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: ðŸ“¥ Checkout del cÃ³digo fuente
        uses: actions/checkout@v4
        
      - name: ðŸ› ï¸ Configurar Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: ðŸ” Login a DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          
      - name: ðŸ“‹ Extraer metadata de imagen
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: ðŸš€ Build y Push imagen Docker
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          
      - name: âœ… Verificar imagen creada
        run: |
          echo "âœ… Imagen Docker creada exitosamente:"
          echo "ðŸ“¦ Nombre: ${{ env.DOCKER_IMAGE_NAME }}"
          echo "ðŸ·ï¸ Tags: ${{ steps.meta.outputs.tags }}"
          echo "ðŸ” Digest: ${{ steps.build.outputs.digest }}"

  # Job 2: Deploy a VPS
  deploy-to-vps:
    name: ðŸŒ Deploy a VPS
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    environment: 
      name: ${{ github.event.inputs.deploy_environment || 'production' }}
      url: http://${{ secrets.SERVER_HOST }}
    
    steps:
      - name: ðŸ“¥ Checkout para scripts de deploy
        uses: actions/checkout@v4
        
      - name: ðŸš€ Deploy vÃ­a SSH a VPS
        uses: appleboy/ssh-action@v1.0.3
        env:
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          APP_PORT: ${{ env.APP_PORT }}
          HOST_PORT: ${{ env.HOST_PORT }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          envs: DOCKER_IMAGE,CONTAINER_NAME,APP_PORT,HOST_PORT
          script: |
            echo "ðŸš€ Iniciando deployment en VPS..."
            
            # FunciÃ³n para logging con timestamp
            log() {
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
            }
            
            # Verificar Docker instalado
            if ! command -v docker &> /dev/null; then
              log "âŒ ERROR: Docker no estÃ¡ instalado"
              exit 1
            fi
            
            log "ðŸ“¦ Descargando imagen Docker: $DOCKER_IMAGE"
            if ! docker pull $DOCKER_IMAGE; then
              log "âŒ ERROR: No se pudo descargar la imagen"
              exit 1
            fi
            
            # Backup del contenedor actual (si existe)
            if docker ps -q -f name=$CONTAINER_NAME > /dev/null; then
              log "ðŸ’¾ Creando backup del contenedor actual..."
              docker tag $DOCKER_IMAGE ${DOCKER_IMAGE}-backup-$(date +%Y%m%d-%H%M%S) || true
            fi
            
            log "ðŸ›‘ Deteniendo contenedor existente..."
            docker stop $CONTAINER_NAME || true
            
            log "ðŸ—‘ï¸ Removiendo contenedor existente..."
            docker rm $CONTAINER_NAME || true
            
            log "ðŸš€ Iniciando nuevo contenedor..."
            docker run -d \
              --name $CONTAINER_NAME \
              --restart unless-stopped \
              -p $HOST_PORT:$APP_PORT \
              --health-cmd="curl -f http://localhost:$APP_PORT/health || exit 1" \
              --health-interval=30s \
              --health-timeout=10s \
              --health-retries=3 \
              -e NODE_ENV=production \
              $DOCKER_IMAGE
            
            if [ $? -eq 0 ]; then
              log "âœ… Contenedor iniciado exitosamente"
            else
              log "âŒ ERROR: FallÃ³ el inicio del contenedor"
              
              # Intentar rollback
              log "ðŸ”„ Intentando rollback..."
              BACKUP_IMAGE=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "${DOCKER_IMAGE}-backup" | head -1)
              if [ ! -z "$BACKUP_IMAGE" ]; then
                docker run -d --name $CONTAINER_NAME --restart unless-stopped -p $HOST_PORT:$APP_PORT $BACKUP_IMAGE
                log "ðŸ”„ Rollback completado con imagen: $BACKUP_IMAGE"
              else
                log "âŒ No hay imagen de backup disponible"
              fi
              exit 1
            fi
            
            # Esperar a que el servicio estÃ© listo
            log "â³ Esperando que el servicio estÃ© listo..."
            sleep 15
            
            # Verificar health check
            for i in {1..10}; do
              if docker exec $CONTAINER_NAME curl -f http://localhost:$APP_PORT/health > /dev/null 2>&1; then
                log "âœ… Servicio respondiendo correctamente"
                break
              else
                if [ $i -eq 10 ]; then
                  log "âŒ ERROR: Servicio no responde despuÃ©s de 10 intentos"
                  docker logs $CONTAINER_NAME --tail 50
                  exit 1
                fi
                log "â³ Intento $i/10 - Esperando respuesta del servicio..."
                sleep 10
              fi
            done
            
            # Limpiar imÃ¡genes antiguas (mantener las Ãºltimas 3)
            log "ðŸ§¹ Limpiando imÃ¡genes antiguas..."
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
              grep "${{ env.DOCKER_IMAGE_NAME }}" | \
              tail -n +4 | \
              awk '{print $1}' | \
              xargs -r docker rmi || true
            
            log "ðŸŽ‰ Â¡Deployment completado exitosamente!"
            log "ðŸŒ AplicaciÃ³n disponible en: http://$(hostname -I | awk '{print $1}'):$HOST_PORT"
            
      - name: ðŸ” Verificar deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            echo "ðŸ” Verificando estado del deployment..."
            echo "ðŸ“Š Estado del contenedor:"
            docker ps -f name=${{ env.CONTAINER_NAME }} --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo "ðŸ“ˆ Logs recientes del contenedor:"
            docker logs ${{ env.CONTAINER_NAME }} --tail 10
            
            echo "ðŸ’¾ Uso de recursos:"
            docker stats ${{ env.CONTAINER_NAME }} --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            
      - name: ðŸ“§ Notificar resultado del deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… DEPLOYMENT EXITOSO"
            echo "ðŸŒ AplicaciÃ³n desplegada en: http://${{ secrets.SERVER_HOST }}"
            echo "ðŸš€ Imagen: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }}"
            echo "ðŸ“… Fecha: $(date)"
          else
            echo "âŒ DEPLOYMENT FALLÃ“"
            echo "ðŸ” Revisa los logs para mÃ¡s detalles"
          fi

  # Job 3: Pruebas post-deployment (opcional)
  post-deployment-tests:
    name: ðŸ§ª Pruebas Post-Deployment
    needs: deploy-to-vps
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && success()
    
    steps:
      - name: ðŸŒ Verificar endpoint de salud
        run: |
          echo "ðŸ” Verificando endpoint de salud..."
          MAX_ATTEMPTS=10
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if curl -f -s http://${{ secrets.SERVER_HOST }}/health > /dev/null; then
              echo "âœ… Endpoint de salud respondiendo correctamente"
              exit 0
            else
              echo "â³ Intento $ATTEMPT/$MAX_ATTEMPTS fallido, reintentando en 15 segundos..."
              sleep 15
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done
          
          echo "âŒ ERROR: Endpoint de salud no responde despuÃ©s de $MAX_ATTEMPTS intentos"
          exit 1
          
      - name: ðŸ“Š Generar reporte de deployment
        if: always()
        run: |
          echo "## ðŸ“Š Reporte de Deployment" >> $GITHUB_STEP_SUMMARY
          echo "| MÃ©trica | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŒ Servidor | ${{ secrets.SERVER_HOST }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸš€ Imagen | ${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_TAG }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ“… Fecha | $(date) |" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Estado | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”— URL | http://${{ secrets.SERVER_HOST }} |" >> $GITHUB_STEP_SUMMARY